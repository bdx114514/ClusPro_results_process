# -*- coding: utf-8 -*-
"""fbdd备用方案.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gu5hj4D6SIc63AXQ_WPrs29WZzONwTXV
"""

#备用的傻瓜式方案，没有利用到求解器，但保证能在一个合理的时间内输出结果，一旦常规方案报错则转入此备用方案
# !pip install rdkit

import sys
import re
import numpy as np
import os
import fnmatch
import time
import csv
import math
import random
import argparse
from pathlib import Path
import copy
from rdkit import Chem, DataStructs
from rdkit.Chem.Scaffolds import MurckoScaffold
from rdkit.DataStructs import TanimotoSimilarity
from rdkit.Chem import Draw, Descriptors, AllChem, rdDepictor
from rdkit.Chem import rdMolDescriptors, QED, Lipinski
from random import choice

#验证SMILES是否正确#
def valid_SMILES(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return False
    return True

#将SMILES输出为规范形式#
def cano(sml):
  mol = Chem.MolFromSmiles(sml)
  if mol is not None:
    s123 = Chem.MolToSmiles(mol)
    return s123
  else:
    return(sml)

#通过谷本系数计算两个分子相似性，范围(0,1)#
def sim_by_tanimoto(sml1,sml2):
  ms = [Chem.MolFromSmiles(sml1), Chem.MolFromSmiles(sml2)]
  fps = [Chem.RDKFingerprint(x) for x in ms]
  return DataStructs.FingerprintSimilarity(fps[0], fps[1],TanimotoSimilarity)

def fbdd_backup1(s):
  xx = s.count('C') + s.count('c')
  ban = 0
  list_s = list(s)
  list_ss = []
  if xx <= 5:
    for i in range(len(list_s)):
      tmp = copy.deepcopy(list_s)
      tmp.insert(i, 'C')
      ss = ''.join(tmp)
      valid_SMILES(ss)
      if valid_SMILES(ss):
        list_ss.append(ss)
    for i in range(len(list_s)):
      tmp = copy.deepcopy(list_s)
      tmp.insert(i, 'c')
      ss = ''.join(tmp)
      valid_SMILES(ss)
      if valid_SMILES(ss):
        list_ss.append(ss)
  for i in range(len(list_s)):
    tmp2 = copy.deepcopy(list_s)
    if tmp2[i] == 'C':
      del(tmp2[i])
      ss2 = ''.join(tmp2)
      valid_SMILES(ss2)
      if valid_SMILES(ss2):
        list_ss.append(ss2)
    elif tmp2[i] == 'c':
      del(tmp2[i])
      ss2 = ''.join(tmp2)
      valid_SMILES(ss2)
      if valid_SMILES(ss2):
        list_ss.append(ss2)
  list_sss = list(set(list_ss))
  random.shuffle(list_sss)
  list_w = []
  count1 = 0
  for i in range(len(list_sss)):
    if valid_SMILES(list_sss[i]):
      sd = cano(list_sss[i])
      list_w.append(sd)
      count1 += 1
      if count1 > 10:
        break
  list_w.append(s)
###输入分子增长或缩短一个C，本步输出分子数不超过10个
  
  list_change = []
  for items in list_w:
    list_ww = list(items)
    list_new = []
    for i in range(len(list_ww)):
      temp1 = copy.deepcopy(list_ww)
      if list_ww[i] == 'C':
        temp1[i] = choice(['N','O'])
        newNO = ''.join(temp1)
        if valid_SMILES(newNO):
          list_new.append(newNO)
      elif list_ww[i] == 'c':
        temp1[i] = choice(['n','o'])
        newno = ''.join(temp1)
        if valid_SMILES(newno):
          list_new.append(newno)
    list_change = list_change + list_new
  if len(list_change) > 100:
    random.shuffle(list_change)
    list_change = list_change[:99]
###随机替换碳原子为O或N，本步输出结果不超过100个
  
  return list_change

def fbdd_backup2(lis):
  list_final = []
  list_insert = ['(O)','(N)','(C=O)','(C(=O)O)','(=O)','(C(=O)Cl)','(C)','(F)','(Cl)','(Br)']
  for items in lis:
    
    list_serted = []
    list_i = list(items)
    for i in range(len(list_i)):
      side = choice(list_insert)
      list_x = copy.deepcopy(list_i)
      list_x.insert(i+1,side)
      smli = ''.join(list_x)
      if valid_SMILES(smli):
        list_serted.append(cano(smli))
    list_final = list_final + list_serted
  list_final = list(set(list_final))
  if len(list_final) > 5000:
    random.shuffle(list_final)
    list_final = list_final[:4999]

  list_final.sort()
  list_final.sort(key=len,reverse=False)
###每个位置随机插入预设好的官能团之一，本步输出分子不超过5000个 
  return list_final

def fbdd_backup(sml):
  list1 = fbdd_backup1(sml)
  list2 = fbdd_backup2(list1)
  
  
  qeddict = {}
  newlist = []
  for i in range(len(list2)):
    x = Chem.MolFromSmiles(list2[i])
    qeddict[list2[i]] = QED.qed(x)
  qed2 = (sorted(qeddict.items(), key=lambda item:item[1], reverse=True))[:10]
  for i in range(len(qed2)):
    newlist.append(qed2[i][0])
  return newlist
  # with open(f'try.txt', 'w') as f:
  #   for x in newlist:
  #     f.write(f"{x}\n")

# 调用示例
# fbdd_backup('/content','C[N+](C)(C)CCOC(N)=O.[Cl-]')

