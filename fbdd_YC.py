# -*- coding: utf-8 -*-
"""片段生成最终版.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BKqppsxMZ3XT6zrRMbidFVt0nF0bVE-J
"""

# !pip install rdkit
import sys
import re
import copy
import numpy as np

import os
import fnmatch
import time
import csv
import math
import random
import argparse
from pathlib import Path

import copy
from rdkit import Chem, DataStructs

from rdkit.Chem.BRICS import BRICSDecompose
from rdkit.Chem.BRICS import BreakBRICSBonds
from rdkit.Chem.Scaffolds import MurckoScaffold
from rdkit.Chem.Draw import IPythonConsole
from IPython.display import display

# from tqdm import tqdm

from rdkit.DataStructs import TanimotoSimilarity
from rdkit.Chem import Draw, Descriptors, AllChem, rdDepictor

#验证SMILES是否正确#
def valid_SMILES(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return False
    return True

#将SMILES输出为规范形式#
def cano(sml):
  mol = Chem.MolFromSmiles(sml)
  if mol is not None:
    s123 = Chem.MolToSmiles(mol)
    return s123
  else:
    return(sml)

#通过谷本系数计算两个分子相似性，范围(0,1)#
def sim_by_tanimoto(sml1,sml2):
  ms = [Chem.MolFromSmiles(sml1), Chem.MolFromSmiles(sml2)]
  fps = [Chem.RDKFingerprint(x) for x in ms]
  return DataStructs.FingerprintSimilarity(fps[0], fps[1],TanimotoSimilarity)

def del_star(list1):    #断点原子（原子符号为*）必须处在分子的末端，删除所有断点原子连了超过一根键的分子#
  list2 = []
  for item in list1:
    
    count = 0
    m = Chem.MolFromSmiles(item)
    print('* item:', item)
    for atom in m.GetAtoms():
      if atom.GetSymbol() == '*'  and atom.GetDegree() > 1:
        count += 1
      else:
        count += 0
    
    for bond in m.GetBonds():
      if str(bond.GetBondType()) != 'SINGLE':
        if (bond.GetBeginAtom()).GetSymbol() =='*' or (bond.GetEndAtom()).GetSymbol() == '*':
          count += 1
        else:
          count+= 0
      else:
        count += 0
        
      
    if count == 0:
      
      list2.append(item)
  
  return list2

#将片段所有侧链弹出，根据是否含断点储存在不同列表里#
def popside(m):
  list_m = list(m)
  list_s = []
 
  ct = 0
  def ct_f(i):
    if i >= 0:
      return ct
    else:
      return 0
  for i in range(len(list_m)):
    
    ctl = ct_f(i-1)
    if list_m[i] == '(':
      ct += 1
    elif list_m[i] == ')':
      ct -= 1
    if ct_f(i) != 0 or ct_f(i)-ctl != 0:
      list_s.append(list_m[i])
      if list_m[i] == '*':
        list_m[i] = '&'
      elif list_m[i].isdigit():
        
        list_m[i] = '$'
      else:
        list_m[i] = '~'
  mainc = ''.join(list_m)
  while '~~' in mainc:
    mainc = mainc.replace('~~','~')
  s = ''.join(list_s)
  
  sidec = s.replace(')(',').(')
 
  list_sidec = sidec.split('.')
  list_markc = []
  list_numc = []
  
  for i in range(len(list_sidec)):
    x = re.search('.*\].*',list_sidec[i])
    if x:
      impor = list_sidec[i]
      list_sidec[i] = ''
      list_markc.append(impor)
    
  for i in range(len(list_sidec)):
    if bool(re.search(r'\d',list_sidec[i])):
      numside = list_sidec[i]
      list_sidec[i] = ''
      list_numc.append(numside)  
  while '' in list_sidec:
    list_sidec.remove('')
  while '' in list_markc:
    list_sidec.remove('')
  while '$$' in mainc:
    mainc = mainc.replace('$$','$')
  while '$~$' in mainc:
    mainc = mainc.replace('$~$','$')
  # print(mainc,list_numc)
  while '$&' in mainc:
    mainc = mainc.replace('$&',list_markc[0],1)
    del(list_markc[0])
  while '~$~' in mainc:
    
    mainc = mainc.replace('~$~',list_numc[0],1)
    del(list_numc[0])
  mainc = mainc.replace('~','')
  mainc = mainc.replace('$','')


  
  return mainc,list_sidec,list_numc

#定义一个函数，将片段的主链全部换成C原子，输入字符串输出字符串#
def mainchain_C(s): 
  list_s = list(s)
  for i in range(len(list_s)):
    if list_s[i] in ['C','N','O','S']:
      list_s[i] = 'C'
    elif list_s[i] in ['c','n','o','s']:
      list_s[i] = 'c'
  ss=''.join(list_s)       
  return ss

#给主链增长或缩短一个单位碳原子,输入mainchain_C生成的字符串，输出列表#
def add_cut(s):
  xx = s.count('C') + s.count('c')
  ban = 0
  list_s = list(s)
  list_ss = []
  if xx <= 5:
    for i in range(len(list_s)):
      tmp = copy.deepcopy(list_s)
      tmp.insert(i, 'C')
      ss = ''.join(tmp)
      valid_SMILES(ss)
      if valid_SMILES(ss):
        list_ss.append(ss)
    for i in range(len(list_s)):
      tmp = copy.deepcopy(list_s)
      tmp.insert(i, 'c')
      ss = ''.join(tmp)
      valid_SMILES(ss)
      if valid_SMILES(ss):
        list_ss.append(ss)
  for i in range(len(list_s)):
    tmp2 = copy.deepcopy(list_s)
    if tmp2[i] == 'C':
      del(tmp2[i])
      ss2 = ''.join(tmp2)
      valid_SMILES(ss2)
      if valid_SMILES(ss2):
        list_ss.append(ss2)
    elif tmp2[i] == 'c':
      del(tmp2[i])
      ss2 = ''.join(tmp2)
      valid_SMILES(ss2)
      if valid_SMILES(ss2):
        list_ss.append(ss2)
  list_ss.append(s)
  list_sss = list(set(list_ss))
  list_w = []
  
  for i in range(len(list_sss)):
    if valid_SMILES(list_sss[i]):
      sd = cano(list_sss[i])
      list_w.append(sd)
  list_x = del_star(list_w)
  return list_x

#把主链的一个脂肪碳原子随机替换成O,N，输入应当是前面add_cut函数输出的列表，输出一个较大的列表#
def replace_C(lists,O=True,N=True):
  list123 = []
  for items in lists:
    list_s = list(items)
    list_ss = []
    for i in range(len(list_s)):
      tmp1 = copy.deepcopy(list_s)
      if N:
        if tmp1[i] == 'C':
          tmp1[i] = 'N'
          ss = ''.join(tmp1)
          valid_SMILES(ss)
          if valid_SMILES(ss):
            list_ss.append(ss)
      tmp2 = copy.deepcopy(list_s)
      if O:
        if tmp2[i] == 'C':
          tmp2[i] = 'O'
          ss = ''.join(tmp2)
          valid_SMILES(ss)
          if valid_SMILES(ss):
            list_ss.append(ss)
    
    list123.extend(list_ss)
    list123.extend(lists)
    
  list456=[]
  for i in range(len(list123)):
    list456.append(cano(list123[i]))

  list456 = list(set(list456))
  list456.sort()
  list456.sort(key=len,reverse=False)
  return(list456)

#把主链的一个芳香碳原子随机替换成O,N，输入应当是前面add_cut函数输出的列表，输出一个较大的列表#
def replace_c(lists,o=True,n=True):
  list123 = []
  for items in lists:
    list_s = list(items)
    list_ss = []
    for i in range(len(list_s)):
      tmp1 = copy.deepcopy(list_s)
      if n:
        if tmp1[i] == 'c':
          tmp1[i] = 'n'
          ss = ''.join(tmp1)
          valid_SMILES(ss)
          if valid_SMILES(ss):
            list_ss.append(ss)
      tmp2 = copy.deepcopy(list_s)
      if o:
        if tmp2[i] == 'c':
          tmp2[i] = 'o'
          ss = ''.join(tmp2)
          valid_SMILES(ss)
          if valid_SMILES(ss):
            list_ss.append(ss)
    list123.extend(list_ss)
    list123.extend(lists)  
  
  list456=[]

  for i in range(len(list123)):
    list456.append(cano(list123[i]))

  list456 = list(set(list456))
  list456.sort()
  list456.sort(key=len,reverse=False)  
  return(list456)

#在replace_C的基础上，设置替换脂肪C原子的个数，即迭代执行replace_C n次#
def replace_nC(s,num,O=True,N=True):
  lists = s
  lists_1 = []
  count = 1
  while count <= num:
    lists = replace_C(lists,O,N)
    lists_1.extend(lists)
    count += 1
  lists_1.extend(s)
  lists_2 = list(set(lists_1))
  lists_2.sort()
  lists_2.sort(key=len,reverse=False)
  return(lists_2)

#在replace_c的基础上，设置替换芳香c原子的个数，即迭代执行replace_c n次#
def replace_nc(ss,num,o=True,n=True):
  lists = ss
  lists_1 = []
  count = 1
  while count <= num:
    lists = replace_c(lists,o,n)
    lists_1.extend(lists)
    count += 1
  lists_1.extend(ss)
  lists_2 = list(set(lists_1))
  lists_2.sort()
  lists_2.sort(key=len,reverse=False)
  return(lists_2)

#将所有含断点的侧链放回主链的任意位置（必须放回）,生成半成品片段#
# def insert_markc(m,s):   
#   list_m = list(m)
#   list_m2 = [m]     
#   list_m3 = []
#   while len(s) > 0:
#     mark = s.pop()
#     listx = []
#     for i in range(len(list_m2)):
#       listz = list(list_m2[i])
#       for j in range(1,len(listz)+1):
#         tmp = copy.deepcopy(listz)
#         tmp.insert(j, mark)
#         ss = ''.join(tmp)
#         valid_SMILES(ss)
#         if valid_SMILES(ss):
#           listx.append(cano(ss))
#     list_m2 = listx
 
#   list_m3 = list(set(del_star(list_m2)))
#   list_m3.sort()
#   list_m3.sort(key=len,reverse=False)
#   return list_m3

#将拆下来的其余支链放回任意位置，#
def insert_sidec(m1,s1): #m1是插入标记原子的'半成品'片段列表，s1是不含标记原子的支链列表#
  leng = max(1,len(s1)) #如果s1里没有支链，也会插入最多一个支链#
  side = ['(O)','(N)','(C=O)','(C(=O)O)','(=O)','(C(=O)C)','(C(=O)Cl)','(C)','(CC)','(C1CC1)','(F)','(Cl)','(Br)'] #预设的支链列表#
  side_full = list(set(s1+side)) #合并，去重#
  list1 = []
  for items in m1: #对于每一个半成品片段
    list_i = list(items)
    list2 = []
    list2.append(list_i)
    count = 1
    while count <= leng:          #一个半成品片段经历的插入循环，循环x次，x为s1里的支链数量，至少为1
      for abc in list2:
        lis = list(abc)
        list3 = []
        for i in range(1,len(lis)+1):
          tmp = copy.deepcopy(lis)
          for j in range(len(side_full)):
            tmp2 = copy.deepcopy(tmp)
            tmp2.insert(i,side_full[j])
            ss = ''.join(tmp2)
            if valid_SMILES(ss) is True:
              ss = cano(ss)
              list3.append(ss)
              # list3.append(ss)
        list3 = list(set(list3))
        list1 = list1 + list3
        list2 = list3
        if len(list1) > 5000:
          break  
      count += 1
      if len(list1) > 5000:
        break
      
 
  list1 = del_star(list(set(list1)))
  
  list1.sort()
  list1.sort(key=len,reverse=False)
  
  
      

  return list1

def fragment_based_design(outputs, input_smiles): #主体函数#
  if not valid_SMILES(input_smiles):
    
    return 'SMILES字符串非法，请重新输入'
  else:
    m = Chem.MolFromSmiles(input_smiles)
    m2 = BreakBRICSBonds(m)
    m3 = Chem.MolToSmiles(m2,True)
    list_frag = m3.split('.')
    if len(list_frag)<2:
      print('分子过于简单，优化效果较差，建议重新输入')
    count = 0  
    for items in list_frag:
      backbone = popside(items)[0]
      
      list_side = popside(items)[1]
      

      backbone_c = mainchain_C(backbone)
      
      backbone_addcut = add_cut(backbone_c)
      
      replace1 = replace_nC(backbone_addcut,1)
      
      replace2 = replace_nc(backbone_addcut,1)
      
      replace_all = replace1+replace2
      replace_all = list(set(replace_all))
      
      list_replace = del_star(replace_all)
      list_replace.sort()
      list_comp = []
      lis2 = insert_sidec(list_replace,list_side)
      
      lis3 = del_star(lis2)
      list_comp = list_comp + lis3
      count += 1
      with open(os.path.join(outputs, f'list_{count}.txt'), 'w') as f:
        for x in list_comp:
          f.write(f"{x}\n")

  list_csv = []
  for f_name in os.listdir(outputs):
    if fnmatch.fnmatch(f_name,'*.txt'):
      f_path = os.path.join(outputs, f_name)
      with open(f_path) as f:
        with open(f_path+'.csv','w') as g:
          writer = csv.writer(g)
          writer.writerow(['SMILES', 'MOLWT', 'HBA', 'HBD', 'PSA'])
          for line in f.readlines():
            line = line.strip()
            smiles = line
            x = Chem.MolFromSmiles(line)
            molwt = round(Chem.Descriptors.ExactMolWt(x),2)
            hbd = Chem.Lipinski.NumHDonors(x)
            hba = Chem.Lipinski.NumHAcceptors(x)
            psa = Chem.Descriptors.TPSA(x)
            writer.writerow([str(smiles),str(molwt),str(hba),str(hbd),str(psa)])
          list_csv.append(f_path+'.csv')  
    
  return list_csv
